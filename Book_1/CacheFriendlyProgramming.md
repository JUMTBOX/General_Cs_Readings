## 캐시 친화적 프로그래밍
- CPU는 메모리에 접근하기 이전에 캐시를 확인하기 때문에 캐시가 적중할 경우 느릿느릿한 메모리에 접근할 필요가 없으므로 CPU는 매우 기뻐할 것이다..
- ```따라서 최신 컴퓨터 시스템에서는 프로그램이 메모리에 접근할 때 캐시의 적중률이 매우 중요하다고 할 수 있는데 이를 어떻게 향상시킬 수 있을까?```

### 프로그램의 지역성 원칙
- 이 원칙의 본질은 프로그램이 ```매우 규칙적으로``` 메모리에 접근한다는 것이다.
- 프로그램이 메모리 조각에 접근하고 나서 이 조각을 여러번 참조하는 경우를 일컬어 ```시간적 지역성```이라고 한다.
- ```시간적 지역성```은 캐시 친화성이 매우 높은데, 이는 데이터가 캐시에 있는 한 메모리에 접근하지 않아도 반복적으로 캐시의 적중이 가능하다는 단순한 이유 때문
- 프로그램이 메모리 조각을 참조할 때는 인접한 메모리도 참조할 수 있는데, 이를 ```공간적 지역성```이라고 한다.
- ```공간적 지역성``` 역시 캐시 친화적인데, 캐시 미스가 나서 메모리의 데이터를 캐시에 적재할 때 일반적으로 요청한 메모리의 인접 데이터도 함께
<br/> 캐시에 적재되므로 프로그램이 인접 데이터에 접근할 때 캐시가 적중하게 된다.

### 메모리 풀 사용
- 메모리를 동적으로 할당 받을 때는 일반적으로 ```malloc```을 사용하는데, 이는 비교적 복잡한 과정에 속하고, 
<br/> 우리의 프로그램이 메모리에서 조각을 N개 할당받아야 하는 경우 malloc을 통해 할당받으면 
<br/> 메모리 조각 N개가 힙 영역의 이곳 저곳에 흩어져 있을 가능성이 높기 때문에 ```공간적 지역성```이 그다지 좋지 않다. 
- ```메모리 풀```기술은 커다란 메모리 조각을 미리 할당받으며, 이후에는 메모리를 요청하거나 해제 할 때 더 이상 ```malloc/free```를 거치지 않는다.
- 따라서 ```malloc/free```의 비교적 복잡한 과정에서 오는 부담이 없다.
- 또한 ```메모리 풀을 초기화 할 때 일반적으로 연속적인 메모리 공간을 할당``` 받으며, 우리의 프로그램이 사용하는 데이터 역시 
<br/> 이 연속적인 메모리 공간 내에서 요청되므로 데이터가 집중적으로 모여 있는 형태로 접근이 가능하기 때문에 ```공간적 지역성```이 높아져 캐시 적중률도 훨씬 높아진다.

### ```struct``` 구조체 재배치
- 연결 리스트에 특정 조건을 만족하는 노드가 있는지 판단하려고 할 때, 연결 리스트의 구조체는 다음과 같이 정의된다.
```C++
#define SIZE 100000

struct List 
{
    List* next;
    int arr[SIZE];    
    int value;
};
```
- 이때 탐색 코드는 다음과 같이 작성할 수 있다.

```C++
bool find(struct List* list, int target) 
{
    while(list) 
    {
        if(list->value == target) {
            return true;
        }
    }
}
```
- 이 코드에서 빈번하게 사용되는 항목은 next 포인터와 value 값이며, 배열 arr는 전혀 사용되고 있지 않다.
- 하지만 next 포인터와 value 값이 배열 arr에 의해 멀리 떨어져 있기 때문에 공간적 지역성이 나빠질 수 있다.
- 따라서 더 좋은 방법은 next 포인터와 value 값을 아래와 같이 함께 배치하는 것이다.

```C++
#define SIZE 100000

struct List 
{
    List* next;
    int value;
    int arr[SIZE];    
};
```
- 이와 같이 수정하면 next 포인터와 value 값이 서로 인접해 있기 때문에 캐시에 next 포인터가 있다면 매우 높은 확률로 value 값도 포함되어 있을 수 있다.

### 핫 데이터와 콜드 데이터의 분리
- 앞서 예제로 작성한 구조체는 더 최적화 될 수 있다.
- 일반적으로 연결 리스트에 노드가 하나뿐인 경우는 거의 없으며, 노드가 비교적 많을 때는 연결 리스트에 접근할 때 캐시해야 하는 노드도 비교적 많아진다.
- ```그러나 프로그래머는 캐시 용량이 제한적이라는 사실을 반드시 인식하고 있어야 한다.```
- 연결 리스트 자체가 차지하는 저장 공간이 크면 클수록 캐시에 저장할 수 있는 노드는 줄어든다. 따라서 자주 접근하지 않는 배열 arr를 다른 구조체에 넣고,
<br/> List 구조체 안에 이 구조체를 가리키는 포인터를 추가할 수 있다.
```C++
#define SIZE 100000

struct List 
{
    List* next;
    int value;
    struct Arr* arr;    
};

struct Arr 
{
    int arr[SIZE];
};
```
- 이렇게 하면 List 구조체의 크기는 크게 줄어들고 캐시는 더 많은 노드를 저장할 수 있다.

### 캐시 친화적인 데이터 구조
- 지역성 원칙 관점에서는 배열이 연결리스트보다 낫다. 왜냐하면 배열은 하나의 연속된 (가상)메모리 공간에 할당되지만, 
<br/> 연결 리스트는 일반적으로 이곳 저곳에 흩어져 있을 수 있기 때문이다.
- 다만 노드의 추가와 삭제 빈번하게 발생한다면 연결 리스트가 배열에 비해 훨씬 우수하다.
- 연결 리스트의 자유로운 노드 추가/삭제를 유지하면서 캐시 친화적이고 싶다면, 
<br/> 연결 리스트를 생성할 때 직접 정의한 메모리 풀에서 메모리를 요청하면 각 노드의 메모리 분포가 비교적 간결해지기 때문에 더 나은 공간적 지역성을 보여준다.
