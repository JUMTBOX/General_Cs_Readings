## System Idle Process (유휴 작업)
- 운영체제는 대기열을 이용하여 프로세스를 관리
- 준비 완료 대기열이 비어 있다면 현재 운영 체제가 스케줄링해야하는 프로세스가 없고, CPU가 유휴 상태에 있다는 것을 의미
- 이때도 무엇인가를 해야한다...
```text
  if( queue.empty() ) 
  {
    do_something();
  }
```
- <b>Q</b>: 하지만 커널은 if같은 예외 처리 구문으로 가득하기 때문에 이렇게 작성할 경우 코드가 너무 번잡해질 우려가 있다.
    <br/> 따라서 ```예외 처리가 없는 더 나은 설계를 고민하여야 하는데... 어떻게 해결해야할까?```
    - <b>A</b>: ```대기열을 가득 채워 스케줄러가 대기열애서 항상 실행 할 수 있는 프로세스를 찾을 수 있도록 한다.```

- 이를 위하여 커널 설계자는 유휴 작업이라는 것을 만들었는데, 이것이 바로 윈도우의 ```System Idle Process``` 이다.
- 시스템에 스케줄링 가능한 프로세스가 없을 때 스케줄러는 이 유휴 프로세스를 꺼내어 실행한다.
<br/> 이때 유휴 프로세스는 항상 준비완료 상태에 있으며 우선 순위는 가장 낮다.

###  그렇다면 이 유휴 프로세스 (System Idle Process)는 무엇을 할까?
- 원래 CPU 설계자는 일찍이 시스템에 유휴 상태가 존재할 가능성을 고려하여 정지를 의미하는 ```halt``` 기계 명령어를 설계하였다.
- 이 명령어는 CPU 내부의 일부 모듈을 절전 상태로 전환하여 전력 소비를 크게 줄인다.
- 가급적 절전 상태를 유지하는 것이 목적이기 때문에 일반적으로 이 명령어도 실행을 위해 순환에 배치된다.
- 이 ```halt``` 명령어는 특권 명령어이기 때문에 커널 상태에서 CPU로만 실행할 수 있다. 
<br/> 프로그래머가 작성한 응용 프로그램은 사용자 상태에서 실행되므로 CPU에게 이 명령어를 실행하게 할 수 없다.

- 유휴 작업 프로세스는 본질적으로 halt 명령어를 계속 실행하는 순환이며, 스케줄러가 유휴 작업 프로세스를 실행하연 CPU는 저전력 상태로 진입하기 시작한다.

- 리눅스 커널에서 이 코드는 다음과 같이 작성된다.
```text
while(1) 
{
  while(!need_rescheduled()) 
  {
    cpuIdle_idle_call();
  }
}
```
- 정리하자면, 컴퓨터 시스템이 유휴 상태일 때 CPU가 하는 일이 바로 이와 같으며 그것은 사실 halt 명령어를 실행하는 것이다.

### 무한 순환 탈출:인터럽트
- 위의 예제로 작성한 순환문은 ```while(1)``` 같은 무한 순환 구조인데, 내부에는 ```break```문도 ```return```문도 없다. 그럼 운영 체제는 어떻게 이 순환을 빠져나올까?
- 또한 프로그래머가 작성한 코드에 ```while(true)```같은 무한 루프가 있어도 해당 프로그램이 CPU를 독점하는 것으로 보이지는 않는다.

- 원래 컴퓨터 운영 체제는 일정 시간마다 타이머 인터럽트(timer interrupt)를 생성하고, CPU는 인터럽트 신호를 감지하고, 운영 체제 내부의 인터럽트 처리 프로그램을 실행한다.
- 상응하는 인터럽트 처리 함수에서는 프로세스가 실행 될 준비가 되었는지 판단하고, 준비가 되었다면 중단되었던 프로세스를 계속 실행한다.
- 준비되어 있지 않았다면 프로세스를 일시 중지시키고, 스케줄러는 준비 완료 상태인 다른 프로세스를 스케줄링한다.
- 앞서 언급했던 ```유휴 프로세스```를 예시로 들어보자면, 유휴 프로세스가 타이머 인터럽트로 일시 중지되면 인터럽트 처리 함수는 시스템에 준비 완료된 프로세스가 있는지 확인하고,
<br/> 없다면 유휴 프로세스를 계속 실행한다.