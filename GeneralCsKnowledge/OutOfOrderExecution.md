## 명령어의 비순차적 실행 (OoOE)
- 원래 CPU는 반드시 엄격하게 프로그래머가 코드를 작성한 순서대로 기계 명령어를 실행하지 않는다.
- 명령어의 비순차적 실행은 다음과 같이 두 단계를 거친다.
1. ```기계 명령어를 생성하는 단계```: 컴파일 중에 명령어를 재정렬한다.
2. ```CPU가 명령어를 실행하는 단계```: 실행 중에 명령어가 비순차적으로 실행된다.

- 지금까지는 CPU의 작업 과정이 간단하게 다음과 같다고 여겨왔다.
1. 기계 명령어(opcode)를 가져온다.
2. 명령어의 피연산자(operand)가 레지스터에 저장되는 등 이미 준비 완료 상태라면 명령어는 실행 단계에 들어간다.
<br/> 가끔 명령어의 피연산자가 아직 메모리에서 레지스터로 올라오지 않아 준비가 완료되지 않았다면, 
<br/> CPU는 피연산자가 메모리에서 레지스터로 저장될 때까지 기다려야한다. 이는 CPU의 속도에 비해 메모리의 접근 속도가 매우 느리기 때문이다.
3. 데이터가 이미 준비되었다면 명령어가 실행된다.
4. 실행 결과를 다시 기록한다.

- 이 명령어 실행 방법은 매우 직관적이지만 필요한 피연산자(operand)가 아직 준비되지 않은 경우 CPU가 반드시 대기해야하기 때문에 비효율적이다.
- 이 문제는 다음과 같이 개선될 수 있다.

1. 기계 명령어를 가져온다.
2. 명령어를 대기열(reservation station)에 넣고 명령어에 필요한 피연산자를 읽는다.
3. 명령어는 대기열에서 피연산자의 준비가 완료될 때까지 대기한다. 이때 이미 준비가 완료된 명령어가 먼저 실행 단계에 들어갈 수 있다.
4. 기계 명령어를 실행하면 실행 결과를 대기열(reorder buffer)에 넣는다.
5. 이전 명령어의 실행 결과가 기록될 때까지 기다렸다가 현재 명령어의 실행 결과를 기록한다. 이는 명령어의 원래 실행 순서에 따라 유효한 결과를 얻기 위한 것

- CPU와 메모리 사이의 속도 차이가 엄청나기 때문에 CPU가 기계 명령어를 엄격한 순서대로 실행하면 명령어가 의존하는 피연산자를 기다리는 동안 
<br/> 파이프라인 내부에 "빈 공간"인 슬롯(slot)이 생긴다. 이때 이미 준비 완료된 다른 명령어로 이 "빈 공간"을 메꿀 수 있다면, 명령어의 실행 속도를 확실히 끌어 올릴 수 있다.
- 따라서 비순차적 실행은 파이프라인을 최대한 활용할 수 있으며, CPU 외부에서 볼 때는 명령어가 순서대로 실행되는 것처럼 보이며 순서대로 실행한 것과 같은 결과를 얻는다.
